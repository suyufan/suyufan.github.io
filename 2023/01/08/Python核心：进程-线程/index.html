<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Python," />










<meta name="description" content="1.进程和线程 进程&amp;线程（概念） 执行一个python程序，默认会创建一个进程，在一个进程里又会创建一个线程。线程是真正工作的单位，而进程是为线程提供资源的单位。 进程是CPU内核资源分配的最小单位，线程是CPU内核调度的最小单位。 一个进程中可以有多个线程，同一个进程中的线程可以共享此进程中的资源  创建方式  创建线程  方式一：  12345678import threadingd">
<meta property="og:type" content="article">
<meta property="og:title" content="Python核心：进程&amp;线程">
<meta property="og:url" content="http://suyufan.github.io/2023/01/08/Python%E6%A0%B8%E5%BF%83%EF%BC%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="笑笑の博客">
<meta property="og:description" content="1.进程和线程 进程&amp;线程（概念） 执行一个python程序，默认会创建一个进程，在一个进程里又会创建一个线程。线程是真正工作的单位，而进程是为线程提供资源的单位。 进程是CPU内核资源分配的最小单位，线程是CPU内核调度的最小单位。 一个进程中可以有多个线程，同一个进程中的线程可以共享此进程中的资源  创建方式  创建线程  方式一：  12345678import threadingd">
<meta property="og:image" content="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218184651385.png">
<meta property="og:image" content="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218185849637.png">
<meta property="og:image" content="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218185953326.png">
<meta property="article:published_time" content="2023-01-08T14:37:56.000Z">
<meta property="article:modified_time" content="2023-01-08T14:39:21.074Z">
<meta property="article:author" content="苏玉璠">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218184651385.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://suyufan.github.io/2023/01/08/Python核心：进程-线程/"/>





  <title>Python核心：进程&线程 | 笑笑の博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">笑笑の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">有一种风雅 趁年华</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://suyufan.github.io/2023/01/08/Python%E6%A0%B8%E5%BF%83%EF%BC%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏玉璠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="笑笑の博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python核心：进程&线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-01-08T22:37:56+08:00">
                2023-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><ul>
<li><p>进程&amp;线程（概念）</p>
<p>执行一个python程序，默认会创建一个进程，在一个进程里又会创建一个线程。线程是真正工作的单位，而进程是为线程提供资源的单位。</p>
<p>进程是CPU内核资源分配的最小单位，线程是CPU内核调度的最小单位。</p>
<p>一个进程中可以有多个线程，同一个进程中的线程可以共享此进程中的资源</p>
</li>
<li><p>创建方式</p>
<ul>
<li><p>创建线程</p>
<ul>
<li>方式一：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a1,a2,a3)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">t = threading.Thread(target=func,args=(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>))</span><br><span class="line"><span class="comment"># 线程开始工作</span></span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<a id="more"></a>

<pre><code>- 方式二：自定义线程类

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'执行此线程'</span>, self._args)</span><br><span class="line"></span><br><span class="line">t = MyThread(args=(<span class="number">100</span>,))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>创建进程</p>
<ul>
<li>方式一</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="comment"># Linux系统fork; win:spawn; mac支持fork和spawn(python3.8默认设置spawn)</span></span><br><span class="line">t = multiprocessing.Process(target=func,args=(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p>如果是spawn模式，进程的创建和执行 都需要放在main函数中。否则会报错，让放在main中。</p>
<p>mac系统指定fork模式时，写上<code>multiprocessing.set_start_method(&#39;fork&#39;)</code></p>
<ul>
<li>方式二: 自定义进程类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'执行此进程'</span>, self._args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">"spawn"</span>)</span><br><span class="line">    p = MyProcess(args=(<span class="string">'xxx'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"继续执行..."</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p><strong>多进程比多线程的开销大</strong>，那是不是证明多线程要比多进程好呢？</p>
</blockquote>
<h3 id="2-GIL锁"><a href="#2-GIL锁" class="headerlink" title="2.GIL锁"></a>2.GIL锁</h3><p>GIL， 全局解释器锁（Global Interpreter Lock），是CPython解释器特有一个玩意，让一个进程中同一个时刻只能有一个线程可以被CPU调用。</p>
<blockquote>
<p>GIL只保证同一时刻一个线程在运行，保证不了数据安全。</p>
<p>由于GIL锁的存在，控制一个进程中同一时刻只有一个线程可以被CPU调度。所以</p>
<pre><code>- 计算密集型，适合多进程开发
- IO密集型，适合多线程开发</code></pre></blockquote>
<p><img src="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218184651385.png" alt="image-20210218184651385"></p>
<p>如果程序想利用 计算机的多核优势，让CPU同时处理一些任务，适合用多进程开发（即使资源开销大）。</p>
<p><img src="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218185849637.png" alt="image-20210218185849637"></p>
<p>如果程序不利用 计算机的多核优势，适合用多线程开发。</p>
<p><img src="https://gitee.com/wupeiqi/python_course/raw/master/day22%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/%E7%AC%94%E8%AE%B0/assets/image-20210218185953326.png" alt="image-20210218185953326"></p>
<p>常见的程序开发中，计算操作需要使用CPU多核优势，IO操作不需要利用CPU的多核优势，所以，就有这一句话：</p>
<ul>
<li><p>计算密集型，用多进程，例如：大量的数据计算【累加计算示例】。</p>
</li>
<li><p>IO密集型，用多线程，例如：文件读写、网络数据传输【下载抖音视频示例】。</p>
</li>
</ul>
<h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h1><h3 id="1-1-多线程"><a href="#1-1-多线程" class="headerlink" title="1.1 多线程"></a>1.1 多线程</h3><p>线程的常见方法：</p>
<ul>
<li><p><code>t.start()</code>,当前线程准备就绪（等待CPU调度，具体怎么调度由CPU决定）</p>
</li>
<li><p><code>t.join()</code>,等待当前线程的任务执行完毕后，再往下执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">loop = <span class="number">10000000</span></span><br><span class="line">number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sub</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        number -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况一：t1先执行，执行完成之后t2开始执行</span></span><br><span class="line">t1 = threading.Thread(target=_add)</span><br><span class="line">t2 = threading.Thread(target=_sub)</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()  <span class="comment"># t1线程执行完毕,才继续往后走</span></span><br><span class="line">t2.start()</span><br><span class="line">t2.join()  <span class="comment"># t2线程执行完毕,才继续往后走</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况二：t1、t2交替执行</span></span><br><span class="line"><span class="comment">#（怎么交替，由CPU调度决定。可以先执行2个t1 再执行3个t2，调度决定，同一时刻只有一个线程在运行。而且可能t1还没执行完，横跳到t2线程）</span></span><br><span class="line">t1 = threading.Thread(target=_add, args=(loop,))</span><br><span class="line">t2 = threading.Thread(target=_sub, args=(loop,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()  <span class="comment"># t1线程执行完毕,才继续往后走</span></span><br><span class="line">t2.join()  <span class="comment"># t2线程执行完毕,才继续往后走</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>t.setDaemon(布尔值)</code>，守护线程（必须放在start之前）</p>
<ul>
<li><code>t.setDaemon(True)</code>，设置为守护线程，主线程执行完毕后，子线程也自动关闭。</li>
<li><code>t.setDaemon(False)</code>，设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。（默认）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'任务'</span>)</span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=task, args=(<span class="number">11</span>,))</span><br><span class="line">t.setDaemon(<span class="literal">True</span>) <span class="comment"># True/False</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'END'</span>)</span><br><span class="line"><span class="comment"># True的时候 输出END 之后结束。（不等待t线程，此时 任务 可能输出了，也可能没来得及输出）</span></span><br><span class="line"><span class="comment"># False的时候 先输出END 再等待5s 最后输出 任务</span></span><br></pre></td></tr></table></figure>

<p>后续3.10版本，弃用了该方法</p>
</li>
<li><p><code>t.name()</code>设置线程名称，需要放在start()方法前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前执行此代码的线程</span></span><br><span class="line">    name = threading.current_thread().name()</span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task, args=(<span class="number">11</span>,))</span><br><span class="line">    t.name(<span class="string">'日魔-&#123;&#125;'</span>.format(i))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-2-线程安全"><a href="#1-2-线程安全" class="headerlink" title="1.2 线程安全"></a>1.2 线程安全</h3><ul>
<li><p>方式一：手动加锁、释放锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 定义锁对象。（线程中的锁 必须是同一把锁）</span></span><br><span class="line">lock_object = threading.RLock()</span><br><span class="line"></span><br><span class="line">loop = <span class="number">10000000</span></span><br><span class="line">number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(count)</span>:</span></span><br><span class="line">    lock_object.acquire() <span class="comment"># 加锁</span></span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">    lock_object.release() <span class="comment"># 释放锁</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_sub</span><span class="params">(count)</span>:</span></span><br><span class="line">    lock_object.acquire() <span class="comment"># 申请锁（等待）</span></span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        number -= <span class="number">1</span></span><br><span class="line">    lock_object.release() <span class="comment"># 释放锁</span></span><br><span class="line">    </span><br><span class="line">t1 = threading.Thread(target=_add, args=(loop,))</span><br><span class="line">t2 = threading.Thread(target=_sub, args=(loop,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()  <span class="comment"># t1线程执行完毕,才继续往后走</span></span><br><span class="line">t2.join()  <span class="comment"># t2线程执行完毕,才继续往后走</span></span><br></pre></td></tr></table></figure>

<p>加锁之后，一个t1线程在执行中 一个t2线程必须等待。不会出现还没执行完 就反复横跳 保证了数据安全。</p>
</li>
<li><p>方式二：基于上下文，自动加锁和释放锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">lock_object = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'开始'</span>)</span><br><span class="line">    <span class="keyword">with</span> lock_object: <span class="comment"># 基于上下文 内部自动执行acquire和release(类似读取文件 自动打开关闭)</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">    print(num)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-线程锁"><a href="#1-3-线程锁" class="headerlink" title="1.3 线程锁"></a>1.3 线程锁</h3><p>手动加锁，一般有两种：Lock和RLock</p>
<ul>
<li>Lock,同步锁<code>lock_object = threading.Lock()</code></li>
<li>RLock，递归锁<code>lock_object = threading.RLock()</code></li>
</ul>
<p>RLock支持多次申请锁和多次释放；Lock不支持。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock_object = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"开始"</span>)</span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    print(<span class="number">123</span>)</span><br><span class="line">    lock_object.release()</span><br><span class="line">    lock_object.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>死锁</p>
<p>死锁，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</p>
</li>
</ul>
<h3 id="1-4-线程池"><a href="#1-4-线程池" class="headerlink" title="1.4 线程池"></a>1.4 线程池</h3><p>官方在python3中才正式提供线程池</p>
<p>线程并不是开的越多越好，可能会导致系统的性能更低</p>
<p>原因：线程越多，切换线程涉及到的上下文切换就会越多，反而耗时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># pool = ThreadPoolExecutor(100)</span></span><br><span class="line"><span class="comment"># pool.submit(函数名,参数1，参数2，参数...)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(video_url,num)</span>:</span></span><br><span class="line">    print(<span class="string">"开始执行任务"</span>, video_url)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池，最多维护10个线程。</span></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">"www.xxxx-&#123;&#125;.com"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">300</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    <span class="comment"># 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。</span></span><br><span class="line">    pool.submit(task, url,<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"END"</span>)</span><br></pre></td></tr></table></figure>

<p>输出10个 ”开始执行任务“ 以及 END ；5S后 输出 开始执行任务的10-19 ；5s后 输出 开始执行任务的20-29 .。。。。。直到，开始执行任务的299</p>
<blockquote>
<p>通过这样操作，节省上下文调度时间</p>
</blockquote>
<h3 id="1-5-单例模式（拓展内容）"><a href="#1-5-单例模式（拓展内容）" class="headerlink" title="1.5 单例模式（拓展内容）"></a>1.5 单例模式（拓展内容）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 返回空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance:</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line">        cls.instance = object.__new__(cls) <span class="comment"># 创建空对象</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单例模式：obj1和obj2的内存地址一样</span></span><br><span class="line">obj1 = Singleton(<span class="string">'su'</span>)</span><br><span class="line">print(obj1)</span><br><span class="line"></span><br><span class="line">obj2 = Singleton(<span class="string">'lemon'</span>)</span><br><span class="line">print(obj2)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 但是，如果多线程的情况，地址可能不一样。为了使得多线程也一样，加上锁</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpSingleton</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 这两行为了优化提升效率，因为申请锁释放锁也需要时间</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance:</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line">        <span class="keyword">with</span> cls.lock:</span><br><span class="line">            <span class="comment"># 返回空对象</span></span><br><span class="line">            <span class="keyword">if</span> cls.instance:</span><br><span class="line">                <span class="keyword">return</span> cls.instance</span><br><span class="line">            cls.instance = object.__new__(cls) <span class="comment"># 创建空对象</span></span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    obj = UpSingleton(<span class="string">'su'</span>)</span><br><span class="line">    print(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h3 id="1-6-常见问题总结"><a href="#1-6-常见问题总结" class="headerlink" title="1.6 常见问题总结"></a>1.6 常见问题总结</h3><ol>
<li><p>简述进程和线程的区别以及应用场景</p>
<p>答：①进程是CPU内核资源分配最小单位，线程是CPU内核调度最小单位。②一个进程中可以有多个线程，同一个进程中的线程可以共享此进程中的资源。③由于GIL锁的存在，控制一个进程中同一时刻只有一个线程可以被CPU调度。所以 计算密集型（多进程开发），IO密集型（多线程开发）</p>
</li>
<li><p>什么是GIL锁</p>
<p>答：GIL是Cpython解释器特有的一个全局解释器锁，控制一个进程中同一时刻只有一个线程可以被CPU调度。同时像列表、字典等常见对象的线程数据安全，也得益于GIL</p>
</li>
</ol>
<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><h3 id="2-1-进程三大模式"><a href="#2-1-进程三大模式" class="headerlink" title="2.1 进程三大模式"></a>2.1 进程三大模式</h3><p>关于在Python中基于multiprocessiong模块操作的进程：</p>
<p>Depending on the platform, <a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Fmultiprocessing.html%23module-multiprocessing"><code>multiprocessing</code></a> supports three ways to start a process. These <em>start methods</em> are</p>
<blockquote>
<ul>
<li><p><em>fork</em>，【“拷贝”几乎所有资源】【支持文件对象/线程锁等传参】【unix】【任意位置开始】【快】</p>
<p>The parent process uses <a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Fos.html%23os.fork"><code>os.fork()</code></a> to fork the Python interpreter. The child process, when it begins, is  effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a  multithreaded process is problematic.Available on Unix only. The default on Unix.</p>
</li>
<li><p><em>spawn</em>，【run参数传必备资源】【不支持文件对象/线程锁等传参】【unix、win】【main代码块开始】【慢】</p>
<p>The parent process starts a fresh python interpreter process. The  child process will only inherit those resources necessary to run the  process object’s <a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Fmultiprocessing.html%23multiprocessing.Process.run"><code>run()</code></a> method. In particular, unnecessary file descriptors and handles from  the parent process will not be inherited. Starting a process using this  method is rather slow compared to using <em>fork</em> or <em>forkserver</em>.Available on Unix and Windows. The default on Windows and macOS.</p>
</li>
<li><p><em>forkserver</em>，【run参数传必备资源】【不支持文件对象/线程锁等传参】【部分unix】【main代码块开始】</p>
<p>When the program starts and selects the <em>forkserver</em> start  method, a server process is started. From then on, whenever a new  process is needed, the parent process connects to the server and  requests that it fork a new process. The fork server process is single  threaded so it is safe for it to use <a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Fos.html%23os.fork"><code>os.fork()</code></a>. No unnecessary resources are inherited.Available on Unix platforms which support passing file descriptors over Unix pipes.</p>
</li>
</ul>
</blockquote>
<h3 id="2-2-多进程"><a href="#2-2-多进程" class="headerlink" title="2.2 多进程"></a>2.2 多进程</h3><p>进程的常见方法：</p>
<ul>
<li><p><code>p.start()</code>，当前进程准备就绪，等待被CPU调度（工作单元其实是进程中的线程）。</p>
</li>
<li><p><code>p.join()</code>，等待当前进程的任务执行完毕后再向下继续执行。</p>
</li>
<li><p><code>p.daemon = 布尔值</code>，守护进程（必须放在start之前）</p>
<ul>
<li><code>p.daemon =True</code>，设置为守护进程，主进程执行完毕后，子进程也自动关闭。</li>
<li><code>p.daemon =False</code>，设置为非守护进程，主进程等待子进程，子进程执行完毕后，主进程才结束。</li>
</ul>
</li>
<li><p>p.name设置进程名称，multiprocessing.current_process().name获取进程名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=func)</span><br><span class="line">        t.start()</span><br><span class="line">    print(os.getpid(), os.getppid())</span><br><span class="line">    print(<span class="string">"线程个数"</span>, len(threading.enumerate()))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"当前进程的名称："</span>, multiprocessing.current_process().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(os.getpid())</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">"spawn"</span>)</span><br><span class="line">    p = multiprocessing.Process(target=task, args=(<span class="string">'xxx'</span>,))</span><br><span class="line">    p.name = <span class="string">"哈哈哈哈"</span></span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"继续执行..."</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取CPU个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">multiprocessing.cpu_count()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-进程间数据共享"><a href="#2-3-进程间数据共享" class="headerlink" title="2.3 进程间数据共享"></a>2.3 进程间数据共享</h3><h3 id="2-4-进程锁"><a href="#2-4-进程锁" class="headerlink" title="2.4 进程锁"></a>2.4 进程锁</h3><h3 id="2-5-进程池"><a href="#2-5-进程池" class="headerlink" title="2.5 进程池"></a>2.5 进程池</h3><p><a href="https://gitee.com/wupeiqi/python_course/blob/master/day23%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/%E7%AC%94%E8%AE%B0/day23.md#3-%E8%BF%9B%E7%A8%8B%E9%94%81" target="_blank" rel="noopener">https://gitee.com/wupeiqi/python_course/blob/master/day23%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/%E7%AC%94%E8%AE%B0/day23.md#3-%E8%BF%9B%E7%A8%8B%E9%94%81</a></p>
<h1 id="3-协程"><a href="#3-协程" class="headerlink" title="3.协程"></a>3.协程</h1><p>计算机中提供了：线程、进程 用于实现并发编程（真实存在）。</p>
<p>协程（Coroutine），是程序员通过代码搞出来的一个东西（非真实存在）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协程也可以被称为微线程，是一种用户态内的上下文切换技术。</span><br><span class="line">简而言之，其实就是通过一个线程实现代码块相互切换执行（来回跳着执行）。</span><br></pre></td></tr></table></figure>

<p><strong>看起来像前端中的异步</strong></p>
<p>在Python中有多种方式可以实现协程，例如：</p>
<ul>
<li><p>greenlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install greenlet</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)        <span class="comment"># 第1步：输出 1</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第3步：切换到 func2 函数</span></span><br><span class="line">    print(<span class="number">2</span>)        <span class="comment"># 第6步：输出 2</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">3</span>)        <span class="comment"># 第4步：输出 3</span></span><br><span class="line">    gr1.switch()    <span class="comment"># 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line">    print(<span class="number">4</span>)        <span class="comment"># 第8步：输出 4</span></span><br><span class="line">    </span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line"></span><br><span class="line">gr1.switch() <span class="comment"># 第1步：去执行 func1 函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>yield</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> func2()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>虽然上述两种都实现了协程，但这种编写代码的方式没啥意义。</p>
<p>这种来回切换执行，可能反倒让程序的执行速度更慢了（相比较于串行）。</p>
<p><strong>协程如何才能更有意义呢？</strong></p>
<blockquote>
<p>不要让用户手动去切换，而是遇到IO操作时能自动切换。</p>
<p>Python在3.4之后推出了asyncio模块 + Python3.5推出async、async语法 ，内部基于协程并且遇到IO请求自动化切换。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(func1()),</span><br><span class="line">    asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">需要先安装：pip3 install aiohttp</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(session, url)</span>:</span></span><br><span class="line">    print(<span class="string">"发送请求："</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        file_name = url.rsplit(<span class="string">'_'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">with</span> open(file_name, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">            file_object.write(content)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg'</span>,</span><br><span class="line">            <span class="string">'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg'</span>,</span><br><span class="line">            <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg'</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>通过上述内容发现，在处理IO请求时，协程通过一个线程就可以实现并发的操作。</p>
<p><strong>协程、线程、进程的区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程，是计算机中可以被cpu调度的最小单元。</span><br><span class="line">进程，是计算机资源分配的最小单元（进程为线程提供资源）。</span><br><span class="line">一个进程中可以有多个线程,同一个进程中的线程可以共享此进程中的资源。</span><br><span class="line"></span><br><span class="line">由于CPython中GIL的存在：</span><br><span class="line">	- 线程，适用于IO密集型操作。</span><br><span class="line">    - 进程，适用于计算密集型操作。</span><br><span class="line"></span><br><span class="line">协程，协程也可以被称为微线程，是一种用户态内的上下文切换技术，在开发中结合遇到IO自动切换，就可以通过一个线程实现并发操作。</span><br><span class="line"></span><br><span class="line">所以，在处理IO操作时，协程比线程更加节省开销（协程的开发难度大一些）。</span><br></pre></td></tr></table></figure>

<p><strong>协程也不是万能的，比如很多个数据同时来回，这时协程处理就会很慢。因为他是一个线程基于IO自动切换。通常协程用来进行数据的下载 下载完成后的数据扔到数据库或者其他其他地方 再有线程进行数据的处理。</strong></p>
<p>现在很多Python中的框架都在支持协程，比如：FastAPI、Tornado、Sanic、Django 3、aiohttp等，企业开发使用的也越来越多（目前不是特别多）。</p>
<p>关于协程，等学习爬虫相关知识之后，再来学习和补充效果更佳。有兴趣想要研究的同学可以参考文章和专题视频：</p>
<ul>
<li><p>文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;6&#x2F;91&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;137057192</span><br></pre></td></tr></table></figure>
</li>
<li><p>视频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1NA411g7yf</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/01/08/DjangoVue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AD%A6%E4%B9%A0/" rel="next" title="DjangoVue前后端分离学习">
                <i class="fa fa-chevron-left"></i> DjangoVue前后端分离学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/04/16/python-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E9%AA%8C%E8%AF%81/" rel="prev" title="python+小程序实现手机号验证">
                python+小程序实现手机号验证 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">苏玉璠</p>
              <p class="site-description motion-element" itemprop="description">人在旅途 风向八方 有人四处走动 是为了寻找一个温暖的地方留下 有人不断告别 是因为没有谁能挽留她的脚步 有人不断被超越 只因为梦想的无法止息</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">141</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:1484114039@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-进程和线程"><span class="nav-number">1.</span> <span class="nav-text">1.进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-GIL锁"><span class="nav-number">2.</span> <span class="nav-text">2.GIL锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-进程"><span class="nav-number"></span> <span class="nav-text">1.进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-多线程"><span class="nav-number">1.</span> <span class="nav-text">1.1 多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-线程安全"><span class="nav-number">2.</span> <span class="nav-text">1.2 线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-线程锁"><span class="nav-number">3.</span> <span class="nav-text">1.3 线程锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-线程池"><span class="nav-number">4.</span> <span class="nav-text">1.4 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-单例模式（拓展内容）"><span class="nav-number">5.</span> <span class="nav-text">1.5 单例模式（拓展内容）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-常见问题总结"><span class="nav-number">6.</span> <span class="nav-text">1.6 常见问题总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-进程"><span class="nav-number"></span> <span class="nav-text">2.进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-进程三大模式"><span class="nav-number">1.</span> <span class="nav-text">2.1 进程三大模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-多进程"><span class="nav-number">2.</span> <span class="nav-text">2.2 多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-进程间数据共享"><span class="nav-number">3.</span> <span class="nav-text">2.3 进程间数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-进程锁"><span class="nav-number">4.</span> <span class="nav-text">2.4 进程锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-进程池"><span class="nav-number">5.</span> <span class="nav-text">2.5 进程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-协程"><span class="nav-number"></span> <span class="nav-text">3.协程</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苏玉璠</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共153.9k字</span>
</div>  

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
