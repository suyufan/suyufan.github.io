<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="腾讯云实习,React," />










<meta name="description" content="前言： 学习一个新东西的开始就是先运行跑起来，跟着官网敲了一遍棋盘游戏 使用JSX而不是JS 接触到： ① props传递数据    ② 为避免this困扰 用箭头函数    ③ 构造函数以super(props)开头    ④ this.state去记忆   ⑤ React Devtools      为什么不用js而是用jsx   123456&#x2F;&#x2F; 1.jsxconst VDOM &#x3D; (  &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="我的带薪学习React笔记">
<meta property="og:url" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="笑笑の博客">
<meta property="og:description" content="前言： 学习一个新东西的开始就是先运行跑起来，跟着官网敲了一遍棋盘游戏 使用JSX而不是JS 接触到： ① props传递数据    ② 为避免this困扰 用箭头函数    ③ 构造函数以super(props)开头    ④ this.state去记忆   ⑤ React Devtools      为什么不用js而是用jsx   123456&#x2F;&#x2F; 1.jsxconst VDOM &#x3D; (  &amp;">
<meta property="og:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E8%AF%B7%E5%81%87%E6%9D%A1.png">
<meta property="og:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E5%9C%A8%E5%8D%B8%E8%BD%BD%E7%BB%84%E4%BB%B6%E4%B8%8A%E6%9B%B4%E6%96%B0state%E6%8A%A5%E9%94%99.png">
<meta property="og:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E5%AE%98%E6%96%B9.png">
<meta property="og:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/redux%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png">
<meta property="og:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/react-redux%E5%8E%9F%E7%90%86%E5%9B%BE.png">
<meta property="og:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E6%9A%B4%E9%9C%B2store.png">
<meta property="article:published_time" content="2021-11-27T01:13:01.000Z">
<meta property="article:modified_time" content="2021-11-27T03:32:02.287Z">
<meta property="article:author" content="苏玉璠">
<meta property="article:tag" content="腾讯云实习">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E8%AF%B7%E5%81%87%E6%9D%A1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://suyufan.github.io/2021/11/27/我的带薪学习React笔记/"/>





  <title>我的带薪学习React笔记 | 笑笑の博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">笑笑の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">有一种风雅 趁年华</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://suyufan.github.io/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="苏玉璠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="笑笑の博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">我的带薪学习React笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-27T09:13:01+08:00">
                2021-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前言：</p>
<p>学习一个新东西的开始就是先运行跑起来，跟着官网敲了一遍<strong>棋盘游戏</strong> 使用JSX而不是JS</p>
<p>接触到：</p>
<p>① props传递数据    ② 为避免this困扰 用箭头函数    ③ 构造函数以super(props)开头    ④ this.state去记忆   ⑤ React Devtools    </p>
<ul>
<li><p>为什么不用js而是用jsx  </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.jsx</span></span><br><span class="line"><span class="keyword">const</span> VDOM = (</span><br><span class="line">  &lt;h1 id=<span class="string">"title"</span>&gt;</span><br><span class="line">    &lt;span&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>h1&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.js</span></span><br><span class="line"><span class="keyword">const</span> VDOM = React.createElement(<span class="string">'h1'</span>,&#123;<span class="attr">id</span>:<span class="string">'title'</span>&#125;,React.createElement(<span class="string">'span'</span>,&#123;&#125;,<span class="string">'Hello'</span>))</span><br></pre></td></tr></table></figure>

<p>jsx经过babel翻译之后，变成js的格式，可以被识别</p>
<p>即jsx创建虚拟DOM是js这种创建方式的语法糖</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>虚拟DOM VS 真实DOM  </p>
<p>关于虚拟DOM：<br>1.本质是Object类型的对象<br>2.虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性<br>3.虚拟DOM最终会被React转化为真实DOM，呈现在页面上</p>
</li>
<li><p>jsx语法规则  </p>
<p>1.定义虚拟DOM时，不要写引号  </p>
<p>2.标签中混入JS表达式时要用{}  </p>
<p>3.样式的类名指定不要用class,要用className  </p>
<p>4.内联样式，要用双括号key:value对的形式去写  </p>
<p>5.只有一个根标签，且必须闭合  </p>
<p>6.标签首字母  </p>
<p>（1）若小写字母开头，则将标签转为html中的同名元素，若html中无该标签对应的同名元素，则报错。虽然报错，但是不干扰其他元素的显示【报错信息：good不能被识别，您是否是在用组件，组件应该大写字母开头】  </p>
<p>（2）若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。报错且页面空白【报错信息：找不到这个组件】</p>
</li>
<li><p>一个小案例：以li的方式动态显示数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据是array   在VDOM中 </span></span><br><span class="line">data.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要记得写index,类似vue 就是diff算法 需要一个key</p>
</li>
</ul>
<h1 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h1><h3 id="1-1-组件"><a href="#1-1-组件" class="headerlink" title="1.1 组件"></a>1.1 组件</h3><h5 id="1-1-1创建组件的两种方式"><a href="#1-1-1创建组件的两种方式" class="headerlink" title="1.1.1创建组件的两种方式"></a>1.1.1创建组件的两种方式</h5><ul>
<li>函数式组件 【简单组件】<br>hooks  </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建函数式组件  因为是组件所以首字母应该大写 记得return</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mycomponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//此处this是undefined 因为babel编译后开启了严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello function component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.渲染</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Mycomponent</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">"test"</span>))</span><br></pre></td></tr></table></figure>

<p>执行渲染过程：<br>    1.React解析组件标签，找到Mycomponent组件<br>    2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转真实DOM,随后呈现在页面上</p>
<ul>
<li>类式组件 【复杂组件】复杂就是有state</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//构造器只在初始化的时候执行一次</span></span><br><span class="line">   <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//render执行 1+n次</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">//render是放在MyComponent的原型对象上，供实例使用</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render中的this:'</span>,<span class="keyword">this</span>); <span class="comment">//this是MyComponent组件的实例对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>class component<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>))</span><br></pre></td></tr></table></figure>

<p>执行了<code>ReactDOM.render(&lt;MyComponent/&gt;)</code>之后，发生类什么？</p>
<pre><code> 1.React解析组件标签，找到MyComponent组件

 2.发现组件是类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法

3.将返回的虚拟DOM转为真实DOM，随后呈现在页面上</code></pre><h5 id="1-1-2组件的三大属性"><a href="#1-1-2组件的三大属性" class="headerlink" title="1.1.2组件的三大属性"></a>1.1.2组件的三大属性</h5><ul>
<li>state</li>
<li>props</li>
<li>refs与事件处理</li>
</ul>
<h3 id="1-2-state"><a href="#1-2-state" class="headerlink" title="1.2 state"></a>1.2 state</h3><ul>
<li><p>绑定事件监听</p>
<p><code>&lt;h onClick={demo}&gt;&lt;/h&gt;</code></p>
<p>function demo() {}</p>
</li>
<li><p>一个小案例：点击切换页面数据(今天天气hot?cool)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isHot</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="comment">//改变this</span></span><br><span class="line">    <span class="keyword">this</span>.changeWeather = <span class="keyword">this</span>.changeWeather.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isHot&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"title"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? 'hot' : 'cool'&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  &#125; </span><br><span class="line">  changeWeather() &#123;</span><br><span class="line">    <span class="comment">//响应事件写在外面的话 这个地方写this this是undefined 因为babel开启了严格模式 就算不开启严格模式 this也是windows 调不到this.state.isHot</span></span><br><span class="line">    <span class="comment">//现在我将它写到了类的里面 作为方法 结果this为什么还是undefined </span></span><br><span class="line">    <span class="comment">//这是因为changeWeather是作为onClick的回调 所以不是通过实例调用 是直接调用</span></span><br><span class="line">    <span class="comment">//出现undefined 是因为类中的方法默认开启了局部的严格模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解决方式 去通过bind改变this</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取原来的isHot值</span></span><br><span class="line">    <span class="keyword">const</span> isHot = <span class="keyword">this</span>.state.isHot</span><br><span class="line">    <span class="comment">//严重注意：state不能直接更改 通过一个内置的API去更改</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>))</span><br></pre></td></tr></table></figure>

<p>即：</p>
<pre><code>1.通过事件去改变状态 1)要在构造函数中通过响应事件去bind(this) 并把结果赋给onClick的回调          2)箭头函数

2.开启严格模式的话 this会由window变为undefined 。1）类中的方法会开启 2）babel会开启

3.不能直接更改state，需要通过this.setState去更改（合并操作，不会影响this.state里的其他属性）</code></pre><p>进行简化：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123; <span class="attr">isHot</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isHot&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"title"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? 'hot' : 'cool'&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  &#125; </span><br><span class="line">  changeWeather = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isHot = <span class="keyword">this</span>.state.isHot</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="1-3-props"><a href="#1-3-props" class="headerlink" title="1.3 props"></a>1.3 props</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对标签属性进行类型，必要性限制</span></span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  name:PropTypes.string.isRequired,   <span class="comment">//限制名字为string且不能为空</span></span><br><span class="line">  age:PropTypes.number, </span><br><span class="line">  speak:PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定默认标签属性</span></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  sex: <span class="string">'未知'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行限制的时候，number string 这些首字母应该小写 否则会与内部的Number,String 产生冲突</p>
<p>function要避免冲突 写为func</p>
<p>function因为this的原因 不能玩state和refs 但是可以玩props。(因为props本身可以作为function的参数)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;name,age,sex&#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Person.propTypes = &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">Person.defaultProps = &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-refs"><a href="#1-4-refs" class="headerlink" title="1.4 refs"></a>1.4 refs</h3><p>勿过度使用，其实用别的方式也可以访问DOM或某个组件的实例</p>
<p>Sring的Refs是过时的 不建议使用 存在效率问题 <strong>官方推荐：用回调函数或createRef API</strong></p>
<ul>
<li><p>回调函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="comment">//展示数据</span></span><br><span class="line">  showData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;input1&#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="built_in">console</span>.log(input1.value);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=&#123;currentNode =&gt; <span class="keyword">this</span>.input1 = currentNode&#125; type=<span class="string">"text"</span> placeholder=<span class="string">"点击按钮提示数据"</span>/&gt;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.showData&#125;&gt;click&lt;<span class="regexp">/button&gt;&amp;nbsp;  </span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ref写回调的含义：拿到当前ref所在的节点 react帮着调这个函数传进去 挂到this实例自身的属性input1上</p>
<p>上面写的是内联函数，更新过程会被执行2次 第一次null 第二次传入参数DOM </p>
<p>可以通过类绑定函数的方式避免这个问题，类绑定函数避免这个问题。大多数情况下都是无关紧要的。</p>
</li>
</ul>
<ul>
<li><p>createRef API</p>
<p>React.createRef()调用后可以返回一个容器，该容器可以存储被ref所标识的节点，该容器是“专人专用”</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myRef = React.createRef() <span class="comment">//创建容器</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.myRef.current.value); <span class="comment">//拿节点的值</span></span><br><span class="line"></span><br><span class="line">&lt;input ref=&#123;<span class="keyword">this</span>.myRef&#125; type=<span class="string">"text"</span> placeholder=<span class="string">"点击按钮提示数据"</span>/&gt;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="1-5-事件处理"><a href="#1-5-事件处理" class="headerlink" title="1.5 事件处理"></a>1.5 事件处理</h3><p>（1）通过onXxx属性指定事件处理函数（注意大小写）</p>
<pre><code>a. React使用的是自定义（合成）事件，而不是使用的原生DOM事件-----为了更好的兼容性

b. React中的事件是通过事件委托方式处理的（委托给组件最外层的元素）-----为了更高效</code></pre><p>（2）通过event.target得到发生事件的DOM元素对象</p>
<pre><code>ps: 如果数据和事件在同一个节点上 那就可以用这种方式拿数据 可以不用ref</code></pre><h3 id="1-6-处理表单"><a href="#1-6-处理表单" class="headerlink" title="1.6 处理表单"></a>1.6 处理表单</h3><p>非受控组件 VS 受控组件</p>
<p>非受控组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">  用户名：&lt;input ref=&#123;c =&gt; <span class="keyword">this</span>.username = c&#125; type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;    </span><br><span class="line">  密码：&lt;input ref=&#123;c =&gt; <span class="keyword">this</span>.password = c&#125; type=<span class="string">"password"</span> name=<span class="string">"password"</span> /&gt;  </span><br><span class="line">  &lt;button&gt;登录&lt;<span class="regexp">/button&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br></pre></td></tr></table></figure>

<p>受控组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存用户名到状态</span></span><br><span class="line">saveUsername = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">username</span>:event.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存密码到状态</span></span><br><span class="line">savePassword = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">password</span>:event.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">  用户名：&lt;input onChange=&#123;<span class="keyword">this</span>.saveUsername&#125; type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;    </span><br><span class="line">  密码：&lt;input onChange=&#123;<span class="keyword">this</span>.savePassword&#125; type=<span class="string">"password"</span> name=<span class="string">"password"</span> /&gt;  </span><br><span class="line">  &lt;button&gt;登录&lt;<span class="regexp">/button&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br></pre></td></tr></table></figure>



<p>（1）非受控组件的每一个数据项都要用ref</p>
<p>（2）受控组件的数据可以维护到状态中，也可以从状态中取出来（感觉类似vue的双向绑定）</p>
<p>官网建议用 受控组件</p>
<ul>
<li><p>一个收集表单数据的小案例</p>
<ul>
<li>用高阶函数+函数柯里化的方式收集</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username:<span class="string">''</span>,</span><br><span class="line">    password:<span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存到状态 高阶函数+函数柯里化</span></span><br><span class="line">saveFormData = <span class="function">(<span class="params">dataType</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(&#123;[dataType]:event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleSubmit = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">  event.preventDefault() <span class="comment">//阻止表单提交</span></span><br><span class="line">  <span class="keyword">const</span> &#123;username,password&#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`用户名：<span class="subst">$&#123;username.value&#125;</span>,密码：<span class="subst">$&#123;password.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="comment">//this.saveFormData() 将函数返回值作为onChange回调 </span></span><br><span class="line">  <span class="comment">//this.saveFormData  将函数作为onChange回调</span></span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      用户名：&lt;input onChange=&#123;<span class="keyword">this</span>.saveFormData(<span class="string">'username'</span>)&#125; type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;    </span><br><span class="line">      密码：&lt;input onChange=&#123;<span class="keyword">this</span>.saveFormData(<span class="string">'password'</span>)&#125; type=<span class="string">"password"</span> name=<span class="string">"password"</span> /&gt;  </span><br><span class="line">      &lt;button&gt;登录&lt;<span class="regexp">/button&gt;  </span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>))</span><br></pre></td></tr></table></figure>

<p>为了抽象出方法 简化代码 </p>
<p>将保存信息的方法进行抽象 —–&gt; 为了区别保存的是谁 —–&gt; 所以将ID作为参数 —–&gt;  因为写了括号 会将函数返回值作为onChange的回调  —–&gt; 所以函数体里面return一个箭头函数  —–&gt; 最后执行的是return里面的内容</p>
</li>
</ul>
<ul>
<li><p>也可以不用柯里化</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存到状态 不用函数柯里化</span></span><br><span class="line">saveFormData = <span class="function">(<span class="params">dataType,event</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;[dataType]:event.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      用户名：&lt;input onChange=&#123; event =&gt; <span class="keyword">this</span>.saveFormData(<span class="string">'username'</span>,event) &#125; type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;    </span><br><span class="line">      密码：&lt;input onChange=&#123; event =&gt; <span class="keyword">this</span>.saveFormData(<span class="string">'password'</span>,event) &#125; type=<span class="string">"password"</span> name=<span class="string">"password"</span> /&gt;  </span><br><span class="line">      &lt;button&gt;登录&lt;<span class="regexp">/button&gt;  </span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为onChange需要一个函数—–&gt; 所以()=&gt;{}  通过react去调用 —–&gt; 拿到event.target.value —–&gt; 再把value作为参数传入this.saveFormData去调用</p>
</li>
</ul>
<h3 id="1-7-生命周期"><a href="#1-7-生命周期" class="headerlink" title="1.7 生命周期"></a>1.7 生命周期</h3><ul>
<li>一个小案例：文字按每次0.1渐隐，到opacity为0的时候，再变为1。并且保证按钮可以正常点击，去卸载组件</li>
</ul>
<p>处理渐隐渐显 和 卸载组件的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">death = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//卸载组件</span></span><br><span class="line">  ReactDOM.unmountComponentAtNode(<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件挂载完毕</span></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取原状态 </span></span><br><span class="line">    <span class="keyword">let</span> &#123;opacity&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="comment">//减小</span></span><br><span class="line">    opacity -= <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">if</span>(opacity &lt;= <span class="number">0</span>) opacity=<span class="number">1</span></span><br><span class="line">    <span class="comment">//设置新的透明度</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;opacity&#125;)</span><br><span class="line">  &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时器不能放在render </p>
<p>因为render会调用1+n次 ，this.setState({opacity})会无限的调render —-&gt; 就炸了</p>
<p>渐隐和渐显的效果可以出来：</p>
<p><img src="/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E8%AF%B7%E5%81%87%E6%9D%A1.png" alt="请假条"></p>
<p>但是再去点击按钮的时候：</p>
<p><img src="/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E5%9C%A8%E5%8D%B8%E8%BD%BD%E7%BB%84%E4%BB%B6%E4%B8%8A%E6%9B%B4%E6%96%B0state%E6%8A%A5%E9%94%99.png" alt="在卸载组件上更新state报错"></p>
<p>报错信息：不能在卸载组件上执行状态更新</p>
<p>原因是：按钮是触发了 death 的回调去卸载组件 而componentDidMount里的定时器还在更新state</p>
<p>解决：在卸载之前要先去clear定时器</p>
<p>现在的问题就变成了怎么去清除：通过绑定给this一个属性 将该属性作为定时器的ID去清除</p>
<ul>
<li><p>方式一：放在death中 卸载前</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">death = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//清除定时器</span></span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  <span class="comment">//卸载组件</span></span><br><span class="line">&#125;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>方式二： 放在componentWillUnmount中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组件将要卸载</span></span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">  <span class="comment">//清除定时器</span></span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>总结一下生命周期回调函数：</p>
<p><img src="/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E5%AE%98%E6%96%B9.png" alt="生命周期"></p>
<h1 id="2-进阶语法"><a href="#2-进阶语法" class="headerlink" title="2. 进阶语法"></a>2. 进阶语法</h1><h3 id="2-1-虚拟DOM"><a href="#2-1-虚拟DOM" class="headerlink" title="2.1 虚拟DOM"></a>2.1 虚拟DOM</h3><p>数据—–&gt;虚拟DOM—–&gt;真实DOMß</p>
<ul>
<li><p>diff比较规则：</p>
<p>a.旧DOM中找到了与新DOM相同的key:</p>
<p>​    i）若虚拟DOM的内容没变，直接使用之前的真实DOM</p>
<p>​    ii）若虚拟DOM的内容变了，替换</p>
<p>b.没有找到相同的key：根据数据创建新的真实DOM，随后渲染到页面</p>
</li>
<li><p>用index作为key可能会出现问题：</p>
<ul>
<li>效率问题：2000条数据前面加一条，用index将位置作为key ,会造成2001条都要进行更新（显然这是一个大问题，对于原来的2000条数据更新是完全没有必要的）</li>
<li>结构中若包含输入类DOM：产生错误的DOM更新，使得输入框的DOM信息错误，界面有问题</li>
</ul>
</li>
</ul>
<p>因此index不建议去唯一标识数据  </p>
<h3 id="2-2-脚手架"><a href="#2-2-脚手架" class="headerlink" title="2.2 脚手架"></a>2.2 脚手架</h3><p>使用在html里面写script引入react核心库，react-dom，babel。然后写<code>type=&#39;text/babel&#39;</code> 让浏览器去将写的jsx翻译为js 。这种方式可能会出现一个问题：白屏（代码量大 翻译不过来）</p>
<p>官网的环境配置流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app 项目名</span><br><span class="line">cd 项目名 </span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>npm run build 会生成优化版本</p>
<p>jsx文件，安装ES7…插件之后</p>
<ul>
<li>rcc 类定义的组件</li>
<li>rfc 函数定义的组件</li>
</ul>
<h3 id="2-3-react-ajax"><a href="#2-3-react-ajax" class="headerlink" title="2.3 react ajax"></a>2.3 react ajax</h3><p>React本身只关注界面，并不包含发送ajax请求的代码。即没有React.get(url)这种写法</p>
<p>可以通过axios或者fetch去处理请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'url'</span>).then(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'联系服务器成功了'</span>);</span><br><span class="line">        <span class="keyword">return</span> response.json() <span class="comment">//作为下一个then的实例</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    error =&gt; &#123;</span></span><br><span class="line"><span class="comment">        console.log('联系服务器失败了',error);</span></span><br><span class="line"><span class="comment">        return new Promise(()=&gt;&#123;&#125;) //拦截 不进行下一个then</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">).then(</span><br><span class="line">    response =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'获取数据成功了'</span>,response); &#125;,</span><br><span class="line">    <span class="comment">//error =&gt; &#123; console.log( '获取数据失败了',error ); &#125;</span></span><br><span class="line">).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request failed'</span>,error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-组件通信"><a href="#2-4-组件通信" class="headerlink" title="2.4 组件通信"></a>2.4 组件通信</h3><ul>
<li><p>父向子：通过props</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父：return (&lt;Child fatherToChild &#x3D; &#123;data&#125; &#x2F;&gt;)</span><br><span class="line">子：&#123;this.props.fatherToChild&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用context可以避免中间元素传递</p>
</li>
<li><p>PubSub</p>
</li>
</ul>
<p>和vue里用的消息订阅发布是同一个js库，微信小程序也可以用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅消息  常写在componentDidMount</span></span><br><span class="line"><span class="keyword">var</span> token = PubSub.subscribe(<span class="string">'事件名'</span>,事件)</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">PubSub.publish(<span class="string">'事件名'</span>,<span class="string">'消息'</span>)</span><br><span class="line"><span class="comment">//取消订阅</span></span><br><span class="line">PubSub.unsubscribe(token)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-React路由"><a href="#2-5-React路由" class="headerlink" title="2.5 React路由"></a>2.5 React路由</h3><ul>
<li><p>SPA</p>
<p>单页面应用，只有一个完整页面，只做局部更新，多组件</p>
</li>
<li><p>路由基本使用：</p>
<p>1.界面中的导航区，展示区</p>
<p>2.导航区的a标签改为Link <code>&lt;Link to=&#39;/xxx&#39;&gt;&lt;/Link&gt;</code></p>
<p>3.展示区写Route标签进行路径的匹配<code>&lt;Route path=&#39;/xxx&#39; component={Demo}/&gt;</code></p>
<p>4.<code>&lt;App&gt;</code>最外层包裹</p>
</li>
</ul>
<p>安装：npm i react-router-dom   </p>
<p>vue里面是直接叫vue-router</p>
<p>路由：Route</p>
<p>路由器：Router</p>
<ul>
<li><p>靠路由链接实现切换组件（编写路由链接）：<code>&lt;Link to=&quot;/about&quot;&gt;&lt;/Link&gt;</code></p>
</li>
<li><p>注册路由：<code>&lt;Route path=&quot;/about&quot; component={About} /&gt;</code></p>
</li>
<li><p>最好一个页面用一个去包裹，所以经常就是在index.js里渲染的时候 包裹一下<code>&lt;App/&gt;</code></p>
</li>
</ul>
<p>注意：</p>
<p>如果直接用Link(或Route)的话 就会出现一个报错（You should not use Link outside a Router）</p>
<p>此时 如果用Router标签去包裹Link 依旧会报错 指向的是Router.js里面的代码</p>
<p>其实 它这个报错信息并不完整 所以造成理解偏差 导致会想着用将Link写到Router标签里面解决</p>
<p>真正的报错是在Router标签</p>
<p>BrowserRouter   ///</p>
<p>HashRouter     #</p>
<p>要说明是那种Router</p>
<p><strong>路由组件 VS 一般组件：</strong></p>
<p>1.写法不同</p>
<pre><code>一般组件用闭合标签。路由组件用注册路由的方式</code></pre><p>2.存放位置不同</p>
<pre><code>一般组件：components. 路由组件：pages</code></pre><p>3.接收到的props不同</p>
<pre><code>一般组件：传递了什么 就收到什么

路由组件：接收到路由器传来的3个固定的属性：history,location,match,</code></pre><p><strong>路由的严格匹配与模糊匹配：</strong></p>
<p>1.默认使用的是模糊匹配（输入路径必须包含要匹配的路径，且顺序要一致）</p>
<p>2.开启严格匹配<code>exact={true}</code></p>
<p>3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</p>
<p>都匹配不了的时候 一般在最后写个Redirect. 跳转到Redirect指定的路由</p>
<p><strong>向路由组件传递参数：</strong></p>
<p>1.params参数</p>
<p>2.search参数</p>
<p>3.state参数</p>
<ul>
<li><p>React-router-dom 相关的API</p>
<ul>
<li><p>内置组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span><br><span class="line">HashRouter</span><br><span class="line">Route</span><br><span class="line">Redirect</span><br><span class="line">Link</span><br><span class="line">NavLink</span><br><span class="line">Switch</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<p>history对象</p>
<p>match对象</p>
<p>withRouter对象</p>
</li>
</ul>
</li>
</ul>
<h1 id="3-Redux"><a href="#3-Redux" class="headerlink" title="3. Redux"></a>3. Redux</h1><p>是一个专门用于做状态管理的JS库。可以在react,angular,vue等项目中，但跟react配合较多。因为vue里面也有优秀的处理共享状态的库Vuex</p>
<h3 id="3-1-三个核心概念"><a href="#3-1-三个核心概念" class="headerlink" title="3.1 三个核心概念"></a>3.1 三个核心概念</h3><ul>
<li><p>action</p>
<p>type：标识属性，值为字符串，唯一，必要属性</p>
<p>data：数据属性，值为类型任意，可选属性</p>
</li>
<li><p>reducer</p>
<p>用于初始化状态，加工状态</p>
<p>加工时，根据旧的state和action 产生新的state的<strong>纯函数</strong></p>
</li>
<li><p>store</p>
<p>将state，action，reducer联系在一起的对象</p>
</li>
</ul>
<h3 id="3-2-原理图"><a href="#3-2-原理图" class="headerlink" title="3.2 原理图"></a>3.2 原理图</h3><p><img src="/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/redux%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="redux工作原理"></p>
<ul>
<li>安装 npm add redux </li>
</ul>
<p>一个有趣的地方：rendux改变状态之后 不进行render 所以我们要去手动调render</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  <span class="comment">//检测redux中的状态变化，只要变了 就调render</span></span><br><span class="line">  store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//假动作 看着去更新state 其实并没有state 更的是空对象 实际是想通过这行代码去骗render去执行</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 但是如何有100个组件，每个组件里面都要写一个componentDidMount去调render吗？？？？</p>
<p>优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在index.js里面进行检测更新 </span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是这样写的话 如果3000个组件中只有一个变化了 其余2999个也会更新</p>
<p>其实没事 因为render有DOM的diff算法</p>
<p><strong>一个小tips：返回函数：</strong><code>()=&gt;({})</code></p>
<ul>
<li><p>action 分为同步 和 异步</p>
<p>同步是 Object。异步是返回function类型的</p>
<p>action只能接受Object的 要是写异步的 需要再写一个中间件</p>
<p><code>安装redux-thunk：npm add redux-thunk</code></p>
<p>在store.sj中引入thunk。再从redux中导入applyMiddleware,最后一起暴露出去</p>
</li>
</ul>
<h1 id="4-react-redux"><a href="#4-react-redux" class="headerlink" title="4.react-redux"></a>4.react-redux</h1><p>安装：npm add react-redux</p>
<p><img src="/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/react-redux%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="c"></p>
<ul>
<li><p>connect（mapStateToProps,mapDispatchToProps)(CountUI)</p>
</li>
<li><p>Provider</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RenderDOM.render(</span><br><span class="line">  <span class="comment">//react-redux 不需要自己去检测更新了 而且通过Provider可以批量为组件传递store</span></span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo1&gt;&lt;<span class="regexp">/Demo1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Demo2&gt;&lt;/</span>Demo2&gt;</span><br><span class="line">	&lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp"> )</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>汇总reducer 用 combineReducers</p>
</li>
</ul>
<p><strong>redux开发者工具：Redux DevTools</strong></p>
<p>chrome安装插件之后 去vscode安装 npm add redux-devtools-extension</p>
<p>然后去store.js里引入</p>
<p><code>import { composeWithDevTools } from &#39;redux-devtools-extension&#39;</code></p>
<p><img src="/2021/11/27/%E6%88%91%E7%9A%84%E5%B8%A6%E8%96%AA%E5%AD%A6%E4%B9%A0React%E7%AC%94%E8%AE%B0/%E6%9A%B4%E9%9C%B2store.png" alt="截屏2021-07-04 下午4.03.02"></p>
<h1 id="5-Hooks"><a href="#5-Hooks" class="headerlink" title="5.Hooks"></a>5.Hooks</h1><p>前面提到纯函数组件只能做UI，涉及到状态的话，就只能用类组件或者redux<br>类组件的缺点：遇到简单的页面，代码就会很重，并且每创建一个类组件，都要去继承一个React实例<br>至于Redux，很久之前Redux作者就说过，“能用React解决的问题就不用Redux”</p>
<p>React Hooks的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码钩进来  </p>
<p><strong>4种常见的钩子：</strong></p>
<ul>
<li><p>useState() 状态管理<br><code>const [name, setName] = useState(null)</code></p>
</li>
<li><p>useContext() 共享状态<br>React16.X以后支持，避免了react逐层通过Props传递数据</p>
</li>
</ul>
<pre><code class="jsx"><span class="keyword">const</span> AppContext = React.creactContext({})
<span class="keyword">const</span> A = <span class="function"><span class="params">()</span> =&gt;</span> {
  <span class="keyword">const</span> { name } = useContext(AppContext)
}
<span class="keyword">const</span> B = <span class="function"><span class="params">()</span> =&gt;</span> {
  <span class="keyword">const</span> { name } = useContext(AppContext)
}
<span class="keyword">return</span> (
  &lt;AppContext.Provider value=&lt;!--￼<span class="number">26</span>--&gt;&gt;
  &lt;A/&gt;
  &lt;B/&gt;
  &lt;<span class="regexp">/AppContext.Provider&gt;</span>
<span class="regexp">)</span></code></pre>
<ul>
<li><p>useReducer() Action钩子<br><code>const [state, dispatch] = useReducer(reducer, initalState)</code>  </p>
</li>
<li><p>useEffect() 监听状态变化进行刷新<br><code>useEffect(() =&gt; {},[array])</code><br>第一个参数是要进行异步的操作，第二个参数是一个数组。<br>只要这个数组发生变化，useEffect就会执行   </p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%9E%E4%B9%A0/" rel="tag"># 腾讯云实习</a>
          
            <a href="/tags/React/" rel="tag"># React</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/10/Node-koa%E5%88%9D%E8%AF%86/" rel="next" title="Node+koa初识">
                <i class="fa fa-chevron-left"></i> Node+koa初识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/27/Mock%E6%95%B0%E6%8D%AE/" rel="prev" title="Mock数据">
                Mock数据 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">苏玉璠</p>
              <p class="site-description motion-element" itemprop="description">人在旅途 风向八方 有人四处走动 是为了寻找一个温暖的地方留下 有人不断告别 是因为没有谁能挽留她的脚步 有人不断被超越 只因为梦想的无法止息</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:1484114039@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-基础语法"><span class="nav-number">1.</span> <span class="nav-text">1. 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-组件"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.1 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1创建组件的两种方式"><span class="nav-number">1.0.1.0.1.</span> <span class="nav-text">1.1.1创建组件的两种方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2组件的三大属性"><span class="nav-number">1.0.1.0.2.</span> <span class="nav-text">1.1.2组件的三大属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-state"><span class="nav-number">1.0.2.</span> <span class="nav-text">1.2 state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-props"><span class="nav-number">1.0.3.</span> <span class="nav-text">1.3 props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-refs"><span class="nav-number">1.0.4.</span> <span class="nav-text">1.4 refs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-事件处理"><span class="nav-number">1.0.5.</span> <span class="nav-text">1.5 事件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-处理表单"><span class="nav-number">1.0.6.</span> <span class="nav-text">1.6 处理表单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-生命周期"><span class="nav-number">1.0.7.</span> <span class="nav-text">1.7 生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-进阶语法"><span class="nav-number">2.</span> <span class="nav-text">2. 进阶语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-虚拟DOM"><span class="nav-number">2.0.1.</span> <span class="nav-text">2.1 虚拟DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-脚手架"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.2 脚手架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-react-ajax"><span class="nav-number">2.0.3.</span> <span class="nav-text">2.3 react ajax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-组件通信"><span class="nav-number">2.0.4.</span> <span class="nav-text">2.4 组件通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-React路由"><span class="nav-number">2.0.5.</span> <span class="nav-text">2.5 React路由</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Redux"><span class="nav-number">3.</span> <span class="nav-text">3. Redux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-三个核心概念"><span class="nav-number">3.0.1.</span> <span class="nav-text">3.1 三个核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-原理图"><span class="nav-number">3.0.2.</span> <span class="nav-text">3.2 原理图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-react-redux"><span class="nav-number">4.</span> <span class="nav-text">4.react-redux</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Hooks"><span class="nav-number">5.</span> <span class="nav-text">5.Hooks</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苏玉璠</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共141k字</span>
</div>  

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
